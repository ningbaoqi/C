### 输入与输出`<stdio.h>`
+ 文本流是由文本行组成的序列，每一行包含0个或多个字符，并以`\n`结尾；二进制流是由未经处理的字节构成的序列，这些字节记录着内部数据，并具有以下性质，如果在同一个系统中写入二进制流，然后再读取该二进制流，则读出和写入的内容完全相同；打开一个流，将把该流与一个文件或设备连接起来，关闭流将断开这种连接；在C语言中流可分为两大类：文本流和二进制流；文本流是指在流中流动的数据是以字符形式存放的，每个字符用对应的ASCII码表示，占一个字节；二进制流是指流动的数据是按其内存中的存储形式存放的，其中字符用ASCII码表示，占一个字符，而整数和浮点数则用二进制数表示，占一个整数或浮点数的存储空间；在读写一个文件之前，必须通过库函数`fopen`打开该文件，并返回一个随后可以用于文件读写操作的指针；该指针称为文件指针，它指向一个包含文件信息的结构，这些信息包括：缓冲区的位置、缓冲区中当前字符的位置、文件的读或写状态、是否出错或是否已经到达文件结尾等等；用户不必关心这些细节，因为`<stdio.h>`中已经定义了一个包含这些信息的结构`FILE`，在程序中只需按照下列方式声明一个文件指针即可；
```
//fp是一个指向结构FILE的指针，并且，fopen函数返回一个指向结构FILE的指针
FILE *fp;
FILE *fopen(char* name , char* mode);
//在程序中可以这样调用函数，fopen的第一个参数是一个字符串，它包含文件名，第二个参数是访问模式，也是一个字符串，用于指定文件的使用方式，允许的模式包括：读"r"；写"w"以及追加"a"；如果打开一个不存在的文件用于写或追加，该文件将被创建，当以写方式打开一个已存在的文件时，该文件原来的内容将会被覆盖，但是，如果以追加方式打开一个文件，则该文件原来的内容将保留不变，如果发生错误，fopen将返回NULL
fp = fopen(name , mode);
//文件打开后就需要考虑使用哪种方法对文件进行读写，getc从文件中返回下一个字符，它需要知道文件指针，以确定对哪个文件执行操作
int getc(FILE *fp);//如果到达文件尾部或出现错误，该函数返回EOF
int putc(int c , FILE* fp);  //该函数将字符c写入到fp指向的文件中，并返回写入的字符，如果发生错误，则返回EOF，getc和putc是宏而不是函数
```
### 文件操作

|函数|说明|
|------|------|
|`FILE *fopen(const char * filename , const char * mode)`|fopen函数打开filename指定的文件，并返回一个与之相关联的流，如果打开操作失败，则返回NULL；访问模式mode可以是以下合法值之一：`r`打开文本文件用于读；`w`创建文本文件用于写，并删除已存在的内容，如果有的话；`a`追加；打开或创建文本文件，并向文件末尾追加内容；`r+`打开文本文件用于更新（即读和写）；`w+`创建文本文件用于更新，并删除已存在的内容（如果有的话）；`a+`追加；打开或创建文本文件用于更新，写文件时追加到文件末尾；如果在上述访问模式之后再加上b，如`”rb“`或`”w+b“`等，则表示对二进制文件进行操作|
|`FILE *freopen(const char* filename , const char* mode , FILE * stream)`|freopen函数以mode指定的模式打开filename指定的文件，并将该文件关联到stream指定的流，它返回stream；若出错则返回NULL；freopen函数一般用于改变与stdin、stdout、stderr相关联的文件|
|`int fflush(FILE* stream)`|对输出流来说，fflush函数将已写到缓冲区但尚未写入文件的所有数据写到文件中，对输入流来说，其结果是未定义的，如果在写的过程中发生错误，则返回EOF，否则返回0，fflush(NULL)将清洗所有的输出流|
|`int fclose(FILE* stream)`|fclose函数将所有未写入的数据写入stream中，丢弃缓冲区中的所有未读输入数据，并释放自动分配的全部缓冲区，最后关闭流，若出错则返回EOF，否则返回0|
|`int remove(const char* filename)`|remove函数删除filename指定的文件，这样，后续试图打开该文件的操作将失败，如果删除操作失败，则返回一个非0值|
|`int rename(const char* oldname , const char* newname)`|rename函数修改文件的名字，如果操作失败，则返回一个非0值|
|`FILE *tmpfile(void)`|tmpfile函数以模式`"wb+"`创建一个临时文件，该文件在被关闭或程序正常结束时将被自动删除，如果创建操作成功，该函数返回一个流，如果创建文件失败，则返回NULL|
|`char* tmpnam(char s[L_tmpnam])`|tmpnam(NULL)函数创建一个与现有文件名不同的字符串，并返回一个指向一内部静态数组的指针，tmpnam(s)函数把创建的字符串保存到数组s中，并将它作为函数值返回，s中至少要有L_tmpnam个字符的空间，tmpnam函数在每次被调用时均生成不同的名字，在程序执行的过程中，最多只能确保生成TMP_MAX个不同的名字，注意，tmpnam函数只是用于创建一个名字，而不是创建一个文件|
|`int setvbuf(FILE* stream , char* buf , int mode , size_t size)`|setvbuf函数控制流stream的缓冲，在执行读写以及其他任何操作之前必须调用此函数，当mode的值为_IOFBF时，将进行完全缓冲，当mode的值为_IOLBF时，将对文本文件进行行缓冲，当mode的值为_IONBF时，表示不设置缓冲，如果buf的值不是NULL，则setvbuf函数将buf指向的区域作为流的缓冲区，否则将分配一个缓冲区，size决定缓冲区的长度，如果setvbuf函数出错，则返回一个非0值|
|`void setbuf(FILE* stream , char* buf)` |如果buf的值为NULL，则关闭流stream的缓冲，否则setbuf函数等价于(void)setvbuf(stream , buf , _IOFBF , BUFSIZ)|
### 格式化输出

|函数|说明|
|------|-------|
|`int fprintf(File* fp , 格式控制字符串, 输出列表)`|`fp`是文件指针，其他说明和printf函数相同，该函数是将输出列表中各表达式的值，按格式控制字符串中指定的格式写到fp所指的文件中|
|`int printf(const char* format , ...)`|printf(...)函数等价于fprintf(stdout , ......)|
|`int sprintf(char* s , const char* format , ......)`|sprintf函数与printf函数基本相同，但其输出将被写入到字符串s中，并以`\0`结束，s必须足够大，以足够容纳下输出结果，该函数返回实际输出的字符数，不包括`\0`|
+ `printf`函数中的`%d`声明的是打印格式；如`%3d`表示占3个数字宽；`%6d`表示占6个数字宽；`%3.0f`表明待打印的浮点数至少占了3个字符宽，且不带小数点和小数部分；`%6.1f`表明至少占6个字符宽，且小数点后面有一位数字；`%.2f`表明宽度没有限制，但是小数点后面有两位；printf还支持以下格式：`%o`表示八进制数；`%x`表示十六进制数；`%c`表示字符；`%s`表示字符串；`%%`表示`%`本身；
#### 格式化输出格式参数

|printf函数基本的转换字符|输出形式|
|-------|-------|
|`d , i`|int类型；十进制数|
|`o`|int类型；无符号八进制数|
|`x , X`|int类型；无符号十六进制数|
|`u`|int类型；无符号十进制数|
|`c`|int类型；单个字符|
|`s`|char*类型；顺序打印字符串中的字符，直到遇到`\0`或已打印了由精度指定的字符数为止|
|`f`|double类型；十进制小数，其中d表示精度|
|`e, E`|double类型|
|`g , G`|double类型；如果指数小于-4或大于等于精度，则用%e或%E格式输出，否则用%f格式输出，尾部的0和小数点不打印|
|`p`|void*类型；指针|
|`%`|不转换参数，打印一个百分号%|

### 格式化输入

|函数|说明|
|------|------|
|`int fscanf(FILE* stream , const char* format , ......)`|fscanf函数根据格式串format从流stream中读取输入，并把转换后的值赋值给后续各个参数，其中的每个参数都必须是一个指针，当格式串format用完时，函数返回，如果到达文件的末尾或在转换输入前出错，该函数返回EOF，否则，返回实际被转换并赋值的输入项的数目|
|`int scanf(const char* format , ......)`|scanf(......)函数与fscanf(stdin , ......)相同|
|`int sscanf(const char* s , const char* format , ......)`|sscanf(s , .......)函数与scanf(......)等价，所不同的是，前者的输入字符来源于字符串s|

#### scanf函数的基本转换字符

|scanf函数的基本转换字符|说明|
|------|-------|
|`d`|十进制整数，int*类型|
|`i`|整数；int*类型，可以是八进制或十六进制|
|`o`|八进制整数；int*类型|
|`u`|无符号十进制整数；unsigned int*类型|
|`x`|十六进制整数；int*类型|
|`c`|字符；char*类型，将接下来的多个输入字符默认为1个字符存放到指定位置，该转换规范通常不跳过空白符。如果需要读入下一个非空白符，可以使用`%ls`|
|`s`|字符串；char*类型，指向一个足以存放该字符串的字符数组，字符串的末尾将被添加一个结束符`\0`|
|`e , f , g `|浮点数；他可以包括正负号、小数点、指数部分；float*类型|
|`%`|字符%，不进行任何赋值操作|

```
scanf("%d , %s , %d" , &day , &monthname , &year);
```

### 字符输入/输出函数

|函数|说明|
|------|------|
|`int fgetc(FILE * stream)`|该函数是从指定的打开的文件中每次读取一个字符，该函数从fp所指文件中读取一个字符，并将字符的ASCII码值返回，如果遇到文件结束或调用错误，则返回EOF|
|`char* fgets(char* s , int n , FILE* stream)`|fgets函数最多将下n-1个字符读入到数组s中，当遇到换行符时，把换行符读入到数组s中，读取过程终止，数组s以`\0`结尾，fgets函数返回数组s，如果到达文件的末尾或发生错误，则返回NULL|
|`int fputc(char ch , FILE* stream)`|该函数将一个字符写到指定的文件中；ch是待输出的字符变量，fp是文件指针，如果调用成功返回写入字符的ASCII码值，失败则返回EOF即-1|
|`int fputs(const char* s , FILE* stream)`|fputs函数把字符串s不包含字符`\n`输出到流stream中，正常时返回写入文件的字符个数，否则返回EOF|
|`int getc(FILE* strean)`|getc函数等价于fgetc，所不同的是，当getc函数定义为宏时，它可能多次计算stream的值|
|`int getchar(void)`|getchar函数等价于getc(stdin)|
|`char* gets(char * s)`|gets函数把下一个输入行读入到数组s中，并把末尾的换行符替换为字符`\0`，它返回数组s，如果到达文件的末尾或发生错误，则返回NULL|
|`int putc(int c , FILE* stream)`|putc函数等价于fputc，所不同的是，当putc函数定义为宏时，它可能多次计算stream的值|
|`int putchar(int c)`|putchar(c)函数等价于putc(c , stdout)|
|`int puts(const char* s)`|puts函数把字符串s和一个换行符输出到stdout中，如果发生错误，则返回EOF，否则返回一个非负值|
|`int ungetc(int c , FILE* stream)`|ungetc函数把c转换为unsigned char类型，写回到流stream中，下次对该流进行读操作时，将返回该字符，对每个流只能写回一个字符，且此字符不能是EOF，ungetc函数返回被写回的字符，如果发生错误，则返回EOF|

### 直接输入/输出函数

|函数|说明|
|------|------|
|`size_t fread(void * ptr , size_t size , size_t nobj , FILE* stream)`|fread函数从流stream中读取最多nobj个长度为size的对象，并保存到ptr指向的数组中，它返回读取的对象数目，此返回值可能小于nobj，必须通过函数feof和ferror获得结果执行状态，一般用于二进制文件的读写|
|`size_t fwrite(const void* ptr , size_t size , size_t nobj , FILE* stream)`|fwrite函数从ptr指向的数组中读取nobj个长度为size的对象，并输出到流stream中，它返回输出的对象数目，如果发生错误，返回值会小于nobj的值，一般用于二进制文件的读写|

### 文件定位函数

|函数|说明|
|------|------|
|`long lseek(int fd ,  long offset , int origin)`|可以在文件中任意移动位置而不实际读写任何数据，将文件描述符为fd的文件的当前位置设置为offset，其中offset是相对于origin指定的位置而言的，随后进行的读写操作将从此位置开始，origin的值可以为0，1或2，分别用于指定offset从文件开始，从当前位置或从文件结束处开始算起；lseek系统调用返回一个long类型的值，此值表示文件的新位置，若发生错误，则返回-1，标准库函数fseek与系统调用lseek类似，不同的是，前者的第一个参数是FILE* 类型，且在发生错误时返回一个非0值|
|`int fseek(FILE* stream , long offset , int origin)`|fseek函数设置流stream的文件位置，后续的读写操作将从新位置开始，对于二进制文件，此位置被设置为从origin开始的第offset个字符处，origin的值可以为SEEK_SET文件开始处，SEEK_CUR当前位置、SEEK_END文件结束处，对于文本流。offset必须设置为0，或者是由函数ftell返回的值（此时origin的值必须是SEEK_SET），fseek函数在出错时返回一个非0值|
|`long ftell(FILE* stream)`|fteel函数返回stream流的当前文件位置，出错时该函数返回-1L|
|`void rewind(FILE* fp)`|fp是文件指针，指向与它相关联的文件，该函数调用后将文件中的位置指针重新置回文件的开头位置|
|`int fgetpos(FILE* stream , fpos_t* ptr)`|fgetpos函数把stream流的当前位置记录在*ptr中，供随后的fsetpos函数调用使用，若出错则返回一个非0值|
|`int fsetpos(FILE* stream , const fpos_t* ptr)`|fsetpos函数将流stream的当前位置设置为fgetpos记录在*ptr中的位置，若出错则返回一个非0值|

### 错误处理函数

|函数|说明|
|------|------|
|`void clearerr(FILE* stream)`|clearerr函数清除与流stream相关的文件结束符和错误指示符，使它们为0，对同一个文件，只要出错就一直保留，直到遇到clearerr()、rewind()、或其他任何一个输入输出库函数|
|`int feof(FILE* stream)`|该函数是判断文件是否处于文件结束位置，如果函数返回值为0，则表示文件指针没有处于文件结束位置，否则表示文件位置指针位于文件结束位置|
|`int ferror(FILE* stream)`|该函数是用来检查文件在用各种输入输出函数进行读写时是否出错，如果函数返回值为0，表示未出错，如果返回值是一个非0值，表示出错|
|`void perror(const char* s)`|perror(s)函数打印字符串s以及与errno中整型值相应的错误信息，错误信息的具体内容与具体的实现有关|

### 文件的打开和关闭
#### 文件的打开
+ 在对文件进行读写操作之前，必须先执行打开文件的操作，文件的打开操作表示将给用户指定的文件在内存中分配一个FILE结构区，并将该结构的指针返回给用户程序，以后用户程序就可以用此FILE指针来实现对指定文件的存取操作了，打开文件的操作通常调用`FILE* fopen(char* filename , char* type)`其中`filename`是要打开的文件的文件名，一般用双引号括起来，其中也包括用双反斜杠隔开的路径名，`type`参数表示对打开文件的操作方式；

|操作文件方式|含义|
|-------|-------|
|`rt`|只读打开一个文本文件，只允许读操作|
|`wt`|只写打开或建立一个文本文件，只允许写操作|
|`at`|追加打开一个文本文件，并在文件末尾写数据|
|`rb`|只读打开一个二进制文件，只允许读数据|
|`wb`|只写打开或建立一个二进制文件，只允许写数据|
|`ab`|追加打开一个二进制文件，并在文件末尾写数据|
|`rt+`|读写打开一个文本文件，允许读和写|
|`wt+`|读写打开或建立一个文本文件，允许读写|
|`at+`|读写打开一个文本文件，允许读，或在文件末尾追加数据|
|`rb+`|读写打开一个二进制文件，允许读写|
|`wb+`|读写打开或创建一个二进制文件，允许读写|
|`ab+`|读写打开一个二进制文件，允许读，或在文件的末尾追加数据|

+ 当用`fopen()`成功打开一个文件时，该函数返回一个`FILE`指针，如果文件打开失败，将返回一个`NULL`指针；

|注意事项|
|-------|
|`r`：读；`w`：写；`a`：追加；`t`：文本文件，可忽略不写；`b`：二进制文件；`+`：读和写|
|凡是`r`打开一个文件时，该文件必须已经存在，且只能从该文件读出|
|用`w`打开的文件只能向该文件写入，若打开的文件不存在，则以指定的文件名建立该文件，若打开的文件已经存在，则将该文件删除，重新建立一个新文件|
|若要向一个已存在的文件追加新的信息，只能用`a`方式打开文件，但此时该文件必须是存在的，否则将会报错|
|在打开一个文件时，如果出错，`fopen`方法将返回一个空指针值`NULL`，在程序中可以用这一信息来辨别是否完成打开文件的工作，并做相应的处理|
|把一个文本文件读入内存时，要将ASCII码转换为二进制码，而把文件以文本方式写入磁盘时，则要把二进制码转换为ASCII码，因此文本文件的读写要花费较多的转换时间，对二进制文件的写不存在这种转换|
|标准输入文件(键盘)、标准输出文件(显示器)、标准错误输出是由系统打开的，文件指针变量名分别为`stdin`、`stdout`、`stderr`可直接使用|

### 文件的关闭
+ 文件操作完成后，必须要用`int fclose(FILE* stream)`函数将文件关闭，它表示该函数将关闭`FILE`指针对应的文件，并返回一个整数，若成功的关闭了文件，则返回`0`，否则返回一个`非0`值；
