### 指针与地址
+ `指针`是一种`保存变量地址`的变量；使用指针通常可以生成更高效、更紧凑的代码；ANSIC使用`void*`指向void的指针代替char*作为通用指针的类型；通常的机器都是一系列连续编号或编址的存储单元，这些存储单元可以单个进行操纵，也可以连续成组的方式操纵，通常情况下，机器的一个字节可以存放一个char类型的数据；两个相邻的字节存储单元可以存储一个short类型的数据；而4个连续的字节存储单元可存储一个long类型的数据，指针是能够存放一个地址的一组存储单元通常是2个或4个字节；一元运算符`&`可用于取一个对象的地址；
```
p = &c;//将把c的地址赋值给变量p，p为指向c的指针，地址运算符&只能应用于内存中的对象，即变量与数组元素，它不能作用于表达式，常量或register类型的变量
```
+ 一元运算符`*`是间接寻址或直接引用运算符；当它作用于指针时，将访问指针所指向的对象；
```
int x = 1 , y = 2 , z[10];
int *p;  //ip是指向int类型的指针
ip = &x;  //ip指向x
y = *ip;  //y现在的值为1
*ip = 0; //x现在的值为0
ip = &z[0]; // p现在指向z[0]

double *dp , atof(char*); //表明在表达式中，*dp和atof(s)的值都是double类型的，且atof的参数是一个指向char类型的指针
```
+ 指针只能指向某种特定类型的对象，也就是说，每个指针都必须指向某种特定的数据类型，一个例外情况是指向void类型的指针可以存放指向任何类型的指针，但它不能间接引用其自身；由于指针也是变量，所以在程序中可以直接使用，而不必通过间接引用的方法使用；`iq = ip`两个都是指针，这样将把`ip`中的值拷贝到`iq`中，这样，指针`iq`也将指向`ip`指向的对象；
### 地址算术运算
+ `alloc(n)`返回一个指向n个连续字符存储单元的指针，该函数的调用者可利用该指针存储字符序列；`afree(p)`释放已分配的存储空间，以便以后重用，这两个函数都是不完善的，因为，对`afree`函数的调用次序必须与调用`alloc`函数的次序相反，标准库中提供了具有类似功能的函数`malloc`和`free`，他们没有上述限制；指针也可以初始化，通常，对指针有意义的初始化值只能是0或者是表示地址的表达式，对后者来说，表达式所代表的地址必须是此前已定义的具有适当类型的数据的地址；C语言保证，0永远不是有效的数据地址，因此，返回值0可用来表示发生了异常事件；指针与整数之间不能相互转换，但0是唯一的例外，常量0可以赋值给指针，指针也可以和常量0进行比较，程序中经常用符号常量`NULL`代替常量0，这样便于更清晰的说明常量0是指针的特殊值，符号常量`NULL`定义在标准头文件`<stddef.h>`中；如果指针`p`和`q`指向同一个数组的成员，那么它们之间就可以进行类似于`==、!=、<、>=`的关系比较运算，如果`p`指向的数组元素的位置在`q`指向的数组元素位置之前，那么关系表达式`p<q`的值为`true`；任何指针与0进行相等或不相等的比较运算都是有意义的；但是指向不同数组的元素的指针之间的算术或比较运算是没有意义的；
### 指针与数组
+ 一般来说，用指针编写的程序比用数组下标编写的程序执行速度快，但另一方面，用指针来实现的程序理解起来稍微困难一些；`int a[10]`定义一个长度为`10`的`int`数组`a`；它定义了一个由10个对象组成的集合，这10个对象存储在`相邻`的内存区域中，名字分别为`a[0] 、a[1]、......a[9]`；`pa = &a[0]`则可以将指针`pa`指向数组`a`的第0个元素，也就是说，`pa`的值为数组元素`a[0]`的地址；`x = *pa`将把数组元素`a[0]`中的内容复制到变量x中；如果指针`pa`指向`a[0]`，那么`*(pa+1)`引用的是数组元素`a[1]`的内容，`pa+i`是数组元素`a[i]`的地址，`*(pa+i)`引用的是数组元素`a[i]`的内容；无论数组`a`中的元素的类型或数组长度是多少，上面的结论都是正确的；`指针加1`就意味着指向对象的下一个元素；`pa=&a[0]`后，`pa`和`a`具有相同的值，因为数组名所代表的就是该数组最开始的一个元素的地址，所以赋值语句`pa=&a[0]`也可以写成`pa=a`，对数组元素`a[i]`的引用也可以写成`*(a+i)`的形式；`&a[i]`和`a+i`的含义也是相同的；相应的，如果`pa`是一个指针，那么在表达式也可以在它的后面加下标；`pa[i]`与`*(pa+i)`是等价的，简而言之，一个通过数组和下标实现的表达式可等价的通过指针和偏移量实现；但是必须记住：数组名与指针有一个不同之处，指针是一个变量，语句`pa=a`和`pa++`都是合法的，但是数组名不是变量，因此类似的形式的语句是非法的；当把数组名传递给一个函数时，实际上传递的是该数组第一个元素的地址，在被调用函数中，该参数是一个局部变量，因此，数组名参数必须是一个指针，也就是一个存储地址值的变量；在函数定义中，形式参数`char s[]`和`char *s`是等价的，如果将数组名传递给函数，函数可以根据情况判断是按照数组处理还是按照指针处理，随后根据相应的方式操作该参数；`f(&a[2])`和`f(a+2)`都将把起始于`a[2]`的子数组的地址传递给函数`f`；在函数`f`中，参数的声明形式可以是`f(int arr[])`或`f(int *arr)`；
### 指针与函数参数
+ 因为函数参数的传递是值传递，也就是传入函数的参数是原数据的副本，在函数中进行操作的时候，不会影响到原数据；但是要注意，当函数传递的是指针的时候，是将变量的地址传递进来，这样`&a`就是一个指向变量a的指针，这样就会影响到原数据；
### 字符指针与函数
+ 字符串常量是一个字符数组，如`I am a string`在字符串的内部表示中，字符数组以空字符`\0`结尾，字符串常量占据的存储单元数也因此比双引号内的字符数大1；如`char *pmessage；pmessage = "now is the time"；`将把一个指向该字符数组的指针赋值给`pmessage`；
```
char amessage[] = "now is the time"; //amessage只是一个仅仅足够存放初始化字符串以及空字符\0的一维数组，数组中的单个字符可以进行修改，但amessage始终指向同一个存储位置
char* pmessage = "now is the time";  //pmessage是一个指针，其初始指向一个字符串常量，之后它可以被修改以指向其他地址，但如果试图修改字符串的内容，结果是没有定义的
```
+ `strcpy(s , t)`函数将把`t`指向的字符串复制到指针`s`指向的位置；函数`strcmp(s , t)`该函数比较字符串`s`和`t`，并且根据`s`按照字典顺序小于、等于、大于`t`的结果分别返回负整数、0或正整数，该返回值是`s`和`t`由前向后逐字符比较时遇到的第一个不相等字符处的字符的差值；
### 指针数组以及指向指针的指针
```
char *lineptr[MAXLINES];  //表示lineptr是一个具有MAXLINES个元素的一维数组，其中数组的每个元素是一个指向字符类型对象的指针，也就是说，lineptr[i]是一个字符指针，而*lineptr[i]是该指针指向的第i个文本行的首字符
int a ;
int * pa;
int **ppa;//指向指针的指针
pa = &a;
ppa = &pa;
```
### 指向函数的指针
+ 在C语言中，函数本身不是变量，但可以定义指向函数的指针，这种类型的指针可以被赋值，存放在数组中，传递给函数以及作为函数的返回值等等；`int (*comp)(void * , void *)`它表明`comp`是一个指向函数的指针，该函数具有两个`void*`类型的参数，其返回值类型为`int`；`comp`的使用和其声明是一致的，`comp`是一个指向函数的指针，`*comp`代表一个函数，下列语句是对该函数进行调用，`(*comp)(v[i] , v[left])`其中的圆括号是必须的，这样才能保证其中的各个部分正确结合；
```
//把函数的入口地址赋予指向函数的指针变量
int (*pf)();
pf = f;//f为函数名
```
### 复杂声明
```
int *f();  //该函数返回一个指向int类型的指针
int (*pf)();  // 是一个指向函数的指针，该函数返回一个int类型的对象
```
