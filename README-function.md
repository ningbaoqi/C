### 函数的基本知识
+ 如果函数定义中省略了返回值类型，如`dummy(){}`；则默认为`int`类型；在UNIX系统中可以使用`cc main.c getline.c strindex.c；`来编译这三个文件，并把生成的目标代码分别存放在文件`main.o , getline.o , strindex.o`中，然后再把这3个文件一起加载到可执行文件`a.out`中，如果源程序中存在错误如`main.c`文件出现错误，可以通过命令`cc main.c getline.o strindex.o；`对`main.c`文件重新编译，并将编译的结果与以前已编译过的目标文件`getline.o , strindex.o`一起加载到可执行文件中，`cc`命令使用`.c`与`.o`这两个扩展名来区分源文件和目标文件；
### 初始化
+ 在不进行显式初始化的情况下，外部变量和静态变量都将被初始化为0，而自动变量和寄存器变量的初值则没有定义（即初值为无用的信息）；定义标量变量时，可以在变量后紧跟一个等号和一个表达式来初始化变量：`int x = 1;`对于外部变量与静态变量来说，初始化表达式必须是常量表达式，且只初始化一次，对于自动变量和寄存器变量，则在每次进入函数或程序块时都将被初始化；字符数组的初始化比较特殊，可以用一个字符串代替用花括号括起来并用逗号分割的初始化表达式序列如：`char pattern[] = "ould"`等价于`char pattern[] = {'o' , 'u' , 'l' , 'd' , '\0'};`这种情况下，数组长度是5，因为4个字符加上一个字符串结束符`’\0‘`；
### 作用域规则
+ 构成C语言程序的函数与外部变量可以分开进行编译，一个程序可以存放在几个文件中，原先已编译过的函数可以从库中进行加载；外部变量或函数的作用域从声明它的地方开始，到其所在的（待编译的）文件的末尾结束；
```
main(){.......}
int sp = 0;
double val[MAXVAL];
void push(double f){.......}
double pop(void){.......}
```
+ 在`push`和`pop`这两个函数中不需进行任何声明就可以通过名字访问变量`sp`和`val`；但是，这两个变量名不能用在`main`函数中，`push`与`pop`函数也不能用在`main`函数中；另一方面，如果要在外部变量的定义之前使用该变量，或者外部变量的定义与变量的使用不在同一个源文件中，则必须在相应的变量声明中强制性的使用关键字`extern`；
```
int sp;//外部变量声明将为之分配存储单元
double val[MAXVAL];//外部变量声明将为之分配存储单元
extern int sp;//在函数中使用，这两个声明并没有建立变量或为它们分配存储单元
extern double val[];//在函数中使用，这两个声明并没有建立变量或为它们分配存储单元
```
+ 在一个源程序的所有源文件中，一个外部变量只能在某个文件中定义一次，而其他文件可以通过`extern`声明来访问它（定义外部变量的源文件中也可以包含对该外部变量的extern声明），外部变量的定义中必须指定数组的长度，但`extern`声明则不一定要指定数组的长度；
### 外部函数
+ C语言中，凡是不被说明为`内部函数(static)`的函数，均是`外部函数`；外部函数可以被其他源文件中的函数所调用，定义函数时，可以在函数首部的最左端用关键字`extern`显式说明是外部函数；在需要调用外部函数的文件中，对外部函数做声明时，也可以省略`extern`；
```
extern void input(char b[100]){
       .......
}
```
### 参数传递
+ 在C语言中，所有函数参数都是通过值的传递的，也就是说，传递给被调用函数的参数值存放在临时变量中，而不是存放在原来的变量中；在C语言中，被调用函数不能直接修改主调函数中变量的值，而只能修改其似有的临时副本的值；如果是数组参数，情况就有所不同了，当把数组名当作参数时，传递给函数的值是数组起始元素的位置或地址，它并不复制数组元素本身，在被调用函数中，可以通过数组下标访问或修改数组元素的值；
### 局部变量存储方式
+ 局部变量有3种存储类型：`自动类(auto)`、`静态类(static)`、`寄存器类(register)`；

|存储类别|说明|
|-------|-------|
|自动类变量|在函数中定义的变量，如果不显式的指定其存储类型，系统会将其默认为自动类变量，在定义自动类变量时，应该在定义变量的类型名前面使用`auto`关键字也可省略如：`auto float f;`自动类变量是在动态存储区内分配单元的(因而也称为动态变量)，函数返回时，编译系统将释放这些存储单元，即当函数调用结束时，自动类变量不复存在|
|静态类变量|如果希望在函数调用结束后，仍然保留函数中定义的局部变量的值，则可以将该局部变量定义为静态局部变量，在定义静态局部变量时，应该在定义变量的类型名前使用`static`关键字如：`static int x;`静态局部变量在静态存储区中分配存储单元，在整个程序运行期间都不释放，因此，每次函数调用结束后，它的值并不会消失，其值能够保持连续性，静态局部变量是在编译阶段赋初值的，且只赋一次初值，以后调用函数时不再赋初值，而是保留上一次函数调用时的结果|
|寄存器变量|一般情况下，变量(包括静态存储方式和动态存储方式)的值是存放在内存中的，当程序中用到一个变量的值时，由控制器发出指令将内存中该变量的值送到运算器中，经过运算器进行运算，如果需要存数，再从运算器将数据送到内存存放，如果有某些变量使用频繁，则存放取这些变量的值要花不少时间，为提高执行效率，C语言允许将局部变量的值放在运算器里的寄存器中，这样需要用时直接从寄存器中取出参加运算，不必再在内存中去存取，这样就可以提高执行效率，这种变量属于寄存器变量，一般称之为寄存器变量，在定义寄存器变量时，应该在定义变量的类型名前面使用`register`关键字；注：一、只有局部自动变量和形参可以定义为寄存器变量，其他变量如全局变量，局部静态变量，均不允许定义为寄存器变量；二、不能定义任意多个寄存器变量，由于一个计算机系统中的寄存器数量有限，系统不一定把用户申请的所有寄存器变量都保留在寄存器中，当CPU中没有足够的寄存器时，编译程序将认为不适合存放在寄存器中的变量自动按auto变量来处理；三、寄存器变量没有地址，若n为寄存器变量，以&n引用n是错误的表现形式|
